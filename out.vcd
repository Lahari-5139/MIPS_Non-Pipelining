$date
	Tue Nov 27 00:02:17 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module main_tb $end
$var wire 32 ! result [31:0] $end
$var wire 32 " pc_nxt [31:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$scope module uut $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 1 % zero $end
$var wire 5 & write_reg [4:0] $end
$var wire 32 ' write_data [31:0] $end
$var wire 1 ( reg_write $end
$var wire 1 ) reg_dst $end
$var wire 32 * read_data2 [31:0] $end
$var wire 32 + read_data1 [31:0] $end
$var wire 32 , read_data [31:0] $end
$var wire 1 - memto_reg $end
$var wire 1 . mem_write $end
$var wire 1 / mem_read $end
$var wire 1 0 jump $end
$var wire 32 1 instruction [31:0] $end
$var wire 32 2 data_2 [31:0] $end
$var wire 1 3 branch $end
$var wire 1 4 alu_src $end
$var wire 32 5 alu_result [31:0] $end
$var wire 2 6 alu_op [1:0] $end
$var wire 4 7 alu_control [3:0] $end
$var reg 32 8 adder1 [31:0] $end
$var reg 32 9 adder2 [31:0] $end
$var reg 32 : extended [31:0] $end
$var reg 32 ; pc [31:0] $end
$var reg 32 < pc_nxt [31:0] $end
$var reg 32 = result [31:0] $end
$var reg 1 > sel $end
$scope module ALU $end
$var wire 1 # clk $end
$var wire 32 ? data_2 [31:0] $end
$var wire 32 @ data_1 [31:0] $end
$var wire 4 A alu_cntrl [3:0] $end
$var reg 32 B alu_out [31:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module ALU_control $end
$var wire 1 # clk $end
$var wire 6 C func [5:0] $end
$var wire 2 D alu_op [1:0] $end
$var reg 4 E alu_control [3:0] $end
$upscope $end
$scope module Control $end
$var wire 1 # clk $end
$var wire 6 F opcode [5:0] $end
$var reg 2 G alu_op [1:0] $end
$var reg 1 4 alu_src $end
$var reg 1 3 branch $end
$var reg 1 0 jump $end
$var reg 1 / mem_read $end
$var reg 1 . mem_write $end
$var reg 1 - memto_reg $end
$var reg 1 ) reg_dst $end
$var reg 1 ( reg_write $end
$upscope $end
$scope module Data_memory $end
$var wire 32 H address [31:0] $end
$var wire 1 # clk $end
$var wire 32 I main_address [31:0] $end
$var wire 1 / read_enable $end
$var wire 1 . write_enable $end
$var wire 32 J write_data [31:0] $end
$var wire 32 K read_data [31:0] $end
$upscope $end
$scope module IM $end
$var wire 1 # clk $end
$var wire 32 L pc [31:0] $end
$var reg 32 M instruction [31:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 # clk $end
$var wire 5 N read_reg1 [4:0] $end
$var wire 5 O read_reg2 [4:0] $end
$var wire 1 ( reg_write $end
$var wire 32 P write_data [31:0] $end
$var wire 5 Q write_reg [4:0] $end
$var reg 32 R read_data1 [31:0] $end
$var reg 32 S read_data2 [31:0] $end
$var integer 32 T i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
b0 L
b0 K
bx J
bx I
bx H
b0 G
bx F
bx E
b0 D
bx C
bx B
bx A
bx @
bx ?
x>
bx =
b0 <
b0 ;
b0xxxxxxxxxxxxxxxxxxxxxxxx :
bx 9
bx 8
bx 7
b0 6
bx 5
04
03
bx 2
bx 1
00
0/
0.
0-
b0 ,
bx +
bx *
0)
0(
bx '
bx &
0%
1$
1#
b0 "
bx !
$end
#10
0#
#20
b100000 :
b1 &
b1 Q
b100000 C
b1 O
b0 N
b100011 F
b10 7
b10 A
b10 E
b10001100000000010000000000100000 1
b10001100000000010000000000100000 M
1#
#30
0#
#40
bx ,
bx K
bx '
bx P
b100000 2
b100000 ?
1(
14
1/
1-
b0 *
b0 J
b0 S
b0 +
b0 @
b0 R
1#
#50
0#
#60
b1011 '
b1011 P
b1011 ,
b1011 K
b100000 I
b100000 !
b100000 =
b100000 5
b100000 B
b100000 H
1(
14
1/
1-
1#
#70
0#
#80
b1 "
b1 <
b100000 2
b100000 ?
1(
14
1/
1-
bx *
bx J
bx S
b0 ;
b0 L
0>
b10000001 9
b100000 :
b1 8
1#
0$
#90
0#
#100
b100000 2
b100000 ?
b1 ;
b1 L
b100000 :
b1011 *
b1011 J
b1011 S
1(
14
1/
1-
1#
#110
0#
#120
b10 "
b10 <
b10 &
b10 Q
b10 O
b100000 2
b100000 ?
b10001100000000100000000000100000 1
b10001100000000100000000000100000 M
1(
14
1/
1-
b1 ;
b1 L
b10000010 9
b100000 :
b10 8
1#
#130
0#
#140
b100000 2
b100000 ?
b10 ;
b10 L
b100000 :
b0 *
b0 J
b0 S
1(
14
1/
1-
1#
#150
0#
#160
b11 "
b11 <
b11 &
b11 Q
b11 O
b100000 2
b100000 ?
b10001100000000110000000000100000 1
b10001100000000110000000000100000 M
1(
14
1/
1-
b1011 *
b1011 J
b1011 S
b10 ;
b10 L
b10000011 9
b100000 :
b11 8
1#
#170
0#
#180
b100000 2
b100000 ?
b11 ;
b11 L
b100000 :
b0 *
b0 J
b0 S
1(
14
1/
1-
1#
#190
0#
#200
b100 "
b100 <
bx &
bx Q
bx C
bx O
bx N
bx F
b100000 2
b100000 ?
bx 1
bx M
1(
14
1/
1-
b1011 *
b1011 J
b1011 S
b11 ;
b11 L
b10000100 9
b100000 :
b100 8
1#
#210
0#
#220
bx I
bx !
bx =
bx 5
bx B
bx H
b0 ,
b0 K
bx 2
bx ?
bx '
bx P
b100 ;
b100 L
b0xxxxxxxxxxxxxxxxxxxxxxxx :
bx *
bx J
bx S
bx +
bx @
bx R
0(
04
0/
0-
1#
#230
0#
#240
b101 "
b101 <
b100 ;
b100 L
bx 9
b0xxxxxxxxxxxxxxxxxxxxxxxx :
b101 8
1#
#250
0#
#260
b101 ;
b101 L
b0xxxxxxxxxxxxxxxxxxxxxxxx :
1#
#270
0#
#280
b110 "
b110 <
b101 ;
b101 L
b0xxxxxxxxxxxxxxxxxxxxxxxx :
b110 8
1#
