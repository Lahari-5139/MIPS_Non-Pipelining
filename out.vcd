$date
	Mon Nov 26 23:27:15 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module main_tb $end
$var wire 32 ! result [31:0] $end
$var wire 32 " pc_nxt [31:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$scope module uut $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 1 % zero $end
$var wire 5 & write_reg [4:0] $end
$var wire 32 ' write_data [31:0] $end
$var wire 1 ( reg_write $end
$var wire 1 ) reg_dst $end
$var wire 32 * read_data2 [31:0] $end
$var wire 32 + read_data1 [31:0] $end
$var wire 32 , read_data [31:0] $end
$var wire 1 - memto_reg $end
$var wire 1 . mem_write $end
$var wire 1 / mem_read $end
$var wire 1 0 jump $end
$var wire 32 1 instruction [31:0] $end
$var wire 32 2 data_2 [31:0] $end
$var wire 1 3 branch $end
$var wire 1 4 alu_src $end
$var wire 32 5 alu_result [31:0] $end
$var wire 2 6 alu_op [1:0] $end
$var wire 4 7 alu_control [3:0] $end
$var reg 32 8 adder1 [31:0] $end
$var reg 32 9 adder2 [31:0] $end
$var reg 32 : extended [31:0] $end
$var reg 32 ; pc [31:0] $end
$var reg 32 < pc_nxt [31:0] $end
$var reg 32 = result [31:0] $end
$var reg 1 > sel $end
$scope module ALU $end
$var wire 1 # clk $end
$var wire 32 ? data_2 [31:0] $end
$var wire 32 @ data_1 [31:0] $end
$var wire 4 A alu_cntrl [3:0] $end
$var reg 32 B alu_out [31:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module ALU_control $end
$var wire 1 # clk $end
$var wire 6 C func [5:0] $end
$var wire 2 D alu_op [1:0] $end
$var reg 4 E alu_control [3:0] $end
$upscope $end
$scope module Control $end
$var wire 1 # clk $end
$var wire 6 F opcode [5:0] $end
$var reg 2 G alu_op [1:0] $end
$var reg 1 4 alu_src $end
$var reg 1 3 branch $end
$var reg 1 0 jump $end
$var reg 1 / mem_read $end
$var reg 1 . mem_write $end
$var reg 1 - memto_reg $end
$var reg 1 ) reg_dst $end
$var reg 1 ( reg_write $end
$upscope $end
$scope module Data_memory $end
$var wire 32 H address [31:0] $end
$var wire 1 # clk $end
$var wire 32 I main_address [31:0] $end
$var wire 1 / read_enable $end
$var wire 1 . write_enable $end
$var wire 32 J write_data [31:0] $end
$var wire 32 K read_data [31:0] $end
$upscope $end
$scope module IM $end
$var wire 1 # clk $end
$var wire 32 L pc [31:0] $end
$var reg 32 M instruction [31:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 # clk $end
$var wire 5 N read_reg1 [4:0] $end
$var wire 5 O read_reg2 [4:0] $end
$var wire 1 ( reg_write $end
$var wire 32 P write_data [31:0] $end
$var wire 5 Q write_reg [4:0] $end
$var reg 32 R read_data1 [31:0] $end
$var reg 32 S read_data2 [31:0] $end
$var integer 32 T i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
x>
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
x4
x3
bx 2
bx 1
x0
x/
x.
x-
bx ,
bx +
bx *
x)
x(
bx '
bx &
x%
x$
0#
bx "
bx !
$end
#40
b0xxxxxxxxxxxxxxxxxxxxxxxx :
b1 &
b1 Q
b0 ,
b0 K
b100000 C
b1 O
b0 N
b100011 F
b10001100000000010000000000100000 1
b10001100000000010000000000100000 M
0(
04
0.
0/
03
00
b0 6
b0 D
b0 G
0-
0)
0%
b0 ;
b0 L
b0 "
b0 <
1#
1$
#80
0#
0$
#120
b1 "
b1 <
bx ,
bx K
b100000 2
b100000 ?
bx '
bx P
b0 ;
b0 L
0>
b100000 :
b1 8
b10 7
b10 A
b10 E
b0 *
b0 J
b0 S
b0 +
b0 @
b0 R
1(
14
1/
1-
1#
#160
0#
#200
b1011 '
b1011 P
b1011 ,
b1011 K
b100000 I
b100000 !
b100000 =
b100000 5
b100000 B
b100000 H
b10 &
b10 Q
b10 O
b100000 2
b100000 ?
b10001100000000100000000000100000 1
b10001100000000100000000000100000 M
1(
14
1/
1-
bx *
bx J
bx S
b1 ;
b1 L
b10000001 9
b100000 :
1#
#240
0#
#280
b10 "
b10 <
b100000 2
b100000 ?
b1 ;
b1 L
b10000010 9
b100000 :
b10 8
b0 *
b0 J
b0 S
1(
14
1/
1-
1#
#320
0#
#360
b100000 2
b100000 ?
1(
14
1/
1-
b1011 *
b1011 J
b1011 S
b10 ;
b10 L
b100000 :
1#
#400
0#
#440
b11 "
b11 <
b100000 2
b100000 ?
b10 ;
b10 L
b10000011 9
b100000 :
b11 8
1(
14
1/
1-
1#
#480
